# bug_fixer_agent/prompts.py
from bug_fixer_agent.bug_definitions import BugDefinitions
from bug_fixer_agent.config import Config

class Prompts:
    def __init__(self):
        self.bug_defs = BugDefinitions()
        self.config = Config() 

    def generate_enhanced_prompt(self, bug_name: str, codebase_content: str, analysis: dict) -> str:
        """
        Generates a concise prompt for generating a minimal, targeted code solution.
        """
        bug = self.bug_defs.get_bug_by_name(bug_name)
        
        if not bug:
            return "Error: Bug definition not found." 

        description = bug["description"]
        files_to_check = bug["files"]
        root_cause = bug.get("root_cause", "") # <-- Root Cause is extracted here
        fix_concept = bug.get("fix_summary", "") 
        
        # Extract only the relevant files from the codebase for context
        relevant_content = self._extract_relevant_files(codebase_content, files_to_check)
        
        return f"""Provide **ONLY the corrected code snippet(s)** to fix a specific bug in this Django/React application.
**Your primary goal is minimality and precision.** Do NOT rewrite entire functions/components, change unrelated lines, or alter API/function signatures unless explicitly necessary for the bug and justified by the analysis.
Add functions or variables only when strictly necessary and locally scoped to the fix. **DO NOT remove or modify any code not directly related to fixing this specific bug.**

**BUG NAME:** {bug_name}
**DESCRIPTION:** {description}
**ROOT CAUSE:** {root_cause} # <-- This is included in the prompt
**FIX CONCEPT:** {fix_concept}
**AFFECTED FILES:** {', '.join(files_to_check)}

**ANALYSIS HINTS (Specific guidance on what and what NOT to change):**
{self.get_specific_analysis_prompt(bug_name)}

**CODE CONTEXT (original, buggy files for reference):**
{relevant_content}

**STRICT OUTPUT FORMAT (CRITICAL TO FOLLOW):**
- Output ONLY corrected code snippets.
- For each affected file, start with: `File: <file_path>`
- Immediately follow with a markdown code block (e.g., ```python or ```typescript).
- Inside the code block:
    - Include only the **minimal set of lines that are changed, added, or deleted**.
    - Provide **exactly 1 to 3 lines of *unchanged* surrounding context** (before and after your change) to show precisely where the modification fits.
    - **DO NOT rewrite entire functions, methods, or components.**
    - **DO NOT change function/method signatures** (e.g., parameter names, types, or number of arguments) unless the bug is *specifically* about an incorrect signature for that function.
    - **DO NOT remove or modify any code not directly related to fixing this specific bug.** Preserve all unrelated lines and functionality.
    - Ensure all generated code is syntactically correct and directly solves the bug.
- Close each code block with '```'.
- **DO NOT include diff markers** (`--- a/`, `+++ b/`, `@@`).
- **DO NOT provide ANY explanations, conversational text, or content outside these formatted code blocks.**
- Use separate 'File:' blocks for multiple files if applicable.

**OUTPUT EXAMPLE (Minimal, targeted change):**
File: frontend/src/components/SomeComponent.tsx
```typescript
  // 1-3 lines of original context above the change
  const existingLine = 'value'; // Line immediately preceding the change
  const [data, setData] = useState<DataType>([]); // THIS IS YOUR MODIFIED/ADDED LINE
  // 1-3 lines of original context below the change
  function anotherFunction() {{ /* ... */ }}
```

File: backend/some_app/views.py
```python
# 1-3 lines of original context above the change
class SomeView(APIView):
    def get(self, request):
        return MyModel.objects.filter(user=request.user) # THIS IS YOUR MODIFIED LINE
# 1-3 lines of original context below the change
```
"""

    def generate_prompt(self, bug_name, codebase_content):
        """
        Legacy method for backward compatibility.
        """
        return self.generate_enhanced_prompt(bug_name, codebase_content, {})

    def _extract_relevant_files(self, codebase_content: str, target_files: list) -> str:
        """
        Extracts only the relevant files from the codebase content.
        Includes the file headers for context, as generated by inspector.py.
        """
        lines = codebase_content.split('\n')
        relevant_lines = []
        in_file_block = False 
        is_target_file = False 
        
        for i, line in enumerate(lines):
            if line.startswith('****************************************************************************************************'):
                if i + 1 < len(lines) and lines[i+1].startswith('File: '):
                    current_file_path = lines[i+1][6:].strip()
                    in_file_block = True 
                    is_target_file = current_file_path in target_files 
                    
                    if is_target_file:
                        relevant_lines.append(line) 
                        relevant_lines.append(lines[i+1]) 
                        if i + 2 < len(lines):
                            relevant_lines.append(lines[i+2]) 
                        relevant_lines.append('') 
                    continue 
                else:
                    in_file_block = False
                    is_target_file = False 
                    continue 
            
            if in_file_block and is_target_file:
                relevant_lines.append(line)
            
        return '\n'.join(relevant_lines).strip()


    def get_specific_analysis_prompt(self, bug_name: str) -> str:
        """
        Generates concise analysis hints for each bug type to guide the LLM.
        These hints guide the LLM on where and what to change minimally, and crucially, what to preserve.
        """
        analysis_prompts = {
            "State Management Bug": """
In `frontend/src/components/TodoList.tsx`, within the `handleUpdate` async function:
- The `try...catch` block around `updateTodo` is duplicated/nested. **SIMPLIFY this to one single, correct `try...catch` block for the `handleUpdate` function.**
- The `setTodos` state update logic `setTodos(todos.map(todo => todo.id === id ? updated : todo));` is correct and should be inside the `try` block after `const updated = await updateTodo(id, updates);`.
- **CRITICAL:** Do NOT change the function signature of `handleUpdate`. It MUST remain `(id: number, updates: Partial<Todo>)`.
- Do NOT remove or modify any other lines in the component.
""",
            "CSRF Token Bug": """
In `frontend/src/services/api.ts`, within the `apiCall` async function:
- There is a **syntax error**: an extra `));` after `return response.json();` that causes the script to break. **Remove this erroneous `));` and any redundant error handling after it.**
- The logic to conditionally add the `X-CSRFToken` header for `POST`, `PUT`, and `DELETE` methods using `getCsrfTokenFromCookie()` is **already present and correct** in the provided codebase.
- **CRITICAL:** Do NOT change the function signature of `apiCall`. It MUST remain `(endpoint: string, options: RequestInit = {})`.
- Do NOT rewrite `getCsrfTokenFromCookie` or the entire `apiCall` function. Make only the minimal change to fix the syntax error.
""",
            "Permission Bug": """
In `backend/todos/views.py`, within the `TodoViewSet` class, specifically the `get_queryset` method:
- The queryset correctly filters `Todo` objects by the authenticated user: `filter(user=self.request.user)`.
- **The missing part is the ordering.** Add `.order_by('-created_at')` to the end of the queryset chain.
- **CRITICAL:** Do NOT remove `permission_classes = [IsAuthenticated]` from the `TodoViewSet` class. This is a security feature and must be preserved.
- Do NOT remove or modify any other lines or methods in the `TodoViewSet` class.
""",
            "React useEffect Bug": """
In `frontend/src/components/TodoList.tsx`, locate the `useEffect` hook that calls `fetchTodos`.
- The problem description states an "infinite loop" due to "missing dependencies". The *intended fix* is to ensure its dependency array is empty: `useEffect(() => { fetchTodos(); }, []);`.
- **Carefully check the provided `CODE CONTEXT`. If the `useEffect` already has `[]` as its dependency, then the bug described is already fixed in the provided source code.** In that case, your generated solution should just show the already correct `useEffect` block to confirm it's the intended fix.
- **CRITICAL:** Do NOT rewrite the entire `TodoList` component. Only modify the `useEffect` hook and its immediate surrounding lines (1-3 lines of context). Preserve all other imports, interfaces, and component structure.
""",
            "API Integration Bug": """
In `backend/todos/serializers.py`, within the `TodoSerializer` class:
- The problem is a field name mismatch: backend `completed` should map to frontend `is_completed`, and `created_at` to `created`.
- The provided `CODE CONTEXT` already contains the correct aliasing: `is_completed = serializers.BooleanField(source='completed')` and `created = serializers.DateTimeField(source='created_at', read_only=True)`.
- **CRITICAL:** Ensure the `Meta.fields` list correctly includes ALL necessary fields: `['id', 'title', 'description', 'is_completed', 'created', 'updated_at']`.
- **CRITICAL:** Ensure `read_only_fields = ['created', 'updated_at']` is present in the `Meta` class.
- Do NOT remove `description` or `updated_at` from the `Meta.fields` or `read_only_fields`.
- If the `CODE CONTEXT` already shows the correct structure, your output should simply reflect that correct structure, confirming the existing code is the solution.
""",
        }
        return analysis_prompts.get(bug_name, "Analyze and provide the corrected code snippet.")

    def generate_failure_analysis_prompt(self, bug_name: str, original_error_message: str, previous_ai_generated_code: str = "", relevant_context_code: str = "") -> str:
        """
        Generates a concise prompt for the LLM to analyze a previous failure and provide an improved solution.
        """
        bug = self.bug_defs.get_bug_by_name(bug_name)
        bug_description = bug["description"] if bug else "N/A."

        prompt_parts = [
            f"Previous code solution for '{bug_name}' failed. Analyze why and provide the improved solution.",
            f"**BUG DESCRIPTION:** {bug_description}",
            "",
            "**FAILURE REASON (system report):**",
            f"```\n{original_error_message}\n```",
            "",
            "**PREVIOUS AI-GENERATED CODE (review for flaws - THIS IS YOUR LAST ATTEMPT):**",
            f"```\n{previous_ai_generated_code or 'No code was generated.'}\n```",
            "",
            "**CODE CONTEXT (original, buggy files):**",
            f"```\n{relevant_context_code or 'N/A'}\n```",
            "",
            "**INSTRUCTIONS:**",
            "- ANALYSIS: Explain concisely why the previous code was incorrect/incomplete (e.g., syntax, logic, missed parts, did not follow output format, was not minimal, introduced regressions).",
            "- IMPROVED SOLUTION: Provide the complete, correct, and **most minimal** code fix. **STRICTLY** follow the primary output format ('File: <path>', ```lang, code with 1-3 lines context, ```). DO NOT introduce new regressions.",
        ]
        return "\n".join(prompt_parts)